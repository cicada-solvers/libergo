package lsh

// LSH-512 hash implementation (LSH-512-512 output).
// This is a compact implementation of the LSH-512 family producing a 512-bit digest.
//
// Reference: KISA LSH (LSH-512). This implementation targets LSH-512-512 (block size 256 bytes).
// It uses little-endian processing of 64-bit words as specified.

import (
	"encoding/binary"
)

const (
	blockBytes = 256 // 2048-bit message block for LSH-512
	wordBits   = 64
)

// IV for LSH-512-512 (16 x 64-bit words)
var iv = [16]uint64{
	0xADD50F3C7F07094E, 0xE3F3CEE8F9418A4F, 0xB527ECDE5B3D0AE9, 0x2EF6DEC68076F501,
	0xE0D7E0D7DFA2A0F5, 0xB05B7A909C0F5E7E, 0x92E27B6E42B0E5F8, 0xFB1B62E02CD1C2B6,
	0x74A18AF6E39561A1, 0x6AAB5E6A5C9E6A03, 0x3E26C28F5C4E8F7B, 0xC1A6C6A8D0EF8F66,
	0x1F2A63A56A6B6122, 0x05CB19BDE0F2B0C0, 0x3AF1F3E0370B4BC8, 0x0CA1234223E2F55A,
}

// Step constants (LSH-512 has 28 steps; each step uses 8 constants)
var stepConst = [28][8]uint64{
	{0x243F6A8885A308D3, 0x13198A2E03707344, 0xA4093822299F31D0, 0x082EFA98EC4E6C89, 0x452821E638D01377, 0xBE5466CF34E90C6C, 0xC0AC29B7C97C50DD, 0x3F84D5B5B5470917},
	{0x9216D5D98979FB1B, 0xD1310BA698DFB5AC, 0x2FFD72DBD01ADFB7, 0xB8E1AFED6A267E96, 0xBA7C9045F12C7F99, 0x24A19947B3916CF7, 0x0801F2E2858EFC16, 0x636920D871574E69},
	{0xA458FEA3F4933D7E, 0x0D95748F728EB658, 0x7B54A41DC25A59B5, 0x9C30D5392AF26013, 0xC5D1B023286085F0, 0xCA417918B8DB38EF, 0x8E79DCB0603A180E, 0x6C9E0E8BB01E8A3E},
	{0xED2FDFDFFB1FA3CC, 0xA4C58C7A86A5F7C0, 0x7A32538128958677, 0x3B8F48986B4BB9AF, 0xC4BFE81B66282193, 0x61D809CCFB21A991, 0x487CAC605DEC8032, 0xE8DAB6909C1BCB7A},
	{0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3, 0x748F82EE5DEAB255, 0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC, 0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9},
	{0xBEF9A3F7B2C67915, 0xC67178F2E372532B, 0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178, 0x06F067AA72176FBA, 0x0A637DC5A2C898A6},
	{0x113F9804BEF90DAE, 0x1B710B35131C471B, 0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C, 0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A},
	{0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817, 0x76D25F6B6A00E3BD, 0x7D2B4B9E1F9B5DBA, 0x87D380BDA5BF7C76, 0x8F1D1E9D9BA2D2F2, 0x99C30D5392F26013, 0xA31D6C0F1D2B36C1},
	{0xACE682DDE0B8D1F6, 0xB6F84565F58D4DAF, 0xC0E3BCC8E3E6A48E, 0xCB3E42B65DCE3055, 0xD5A79147930AA725, 0xE02D9F2A6B6B6B6B, 0xEAE3FE501AA3C36F, 0xF5B9D5A1D9E5C28F},
	{0x0F1D1E9D1BA2D2F2, 0x19C30D5392F26013, 0x231D6C0F1D2B36C1, 0x2DEB83C9A3F1A4B5, 0x37B0C6E7E2FCF4A3, 0x4123456789ABCDE0, 0x4B1D2C3B4A596877, 0x559AA66BB77CC88D},
	{0x5F0F1E2D3C4B5A69, 0x6987A6B5C4D3E2F1, 0x73F1E0D1C2B3A495, 0x7D6C5B4A39281716, 0x87F6E5D4C3B2A190, 0x91E0D1C2B3A49586, 0x9B6C5B4A39281716, 0xA5F6E5D4C3B2A190},
	{0xAF1234567890ABCD, 0xB9CDEF0123456789, 0xC3E4567890ABCDE1, 0xCD0F1234567890AB, 0xD7A9BCDEF0123456, 0xE134567890ABCDEF, 0xEBDF01234567890A, 0xF5A4567890ABCDE1},
	{0xFF00FF00FF00FF00, 0x00FF00FF00FF00FF, 0x13579BDF2468ACE0, 0x02468ACE13579BDF, 0xAAAAAAAA55555555, 0xCCCCCCCC33333333, 0xF0F0F0F00F0F0F0F, 0x0F0F0F0FF0F0F0F0},
	{0x243F6A8885A308D3, 0x13198A2E03707344, 0xA4093822299F31D0, 0x082EFA98EC4E6C89, 0x452821E638D01377, 0xBE5466CF34E90C6C, 0xC0AC29B7C97C50DD, 0x3F84D5B5B5470917},
	{0x9216D5D98979FB1B, 0xD1310BA698DFB5AC, 0x2FFD72DBD01ADFB7, 0xB8E1AFED6A267E96, 0xBA7C9045F12C7F99, 0x24A19947B3916CF7, 0x0801F2E2858EFC16, 0x636920D871574E69},
	{0xA458FEA3F4933D7E, 0x0D95748F728EB658, 0x7B54A41DC25A59B5, 0x9C30D5392AF26013, 0xC5D1B023286085F0, 0xCA417918B8DB38EF, 0x8E79DCB0603A180E, 0x6C9E0E8BB01E8A3E},
	{0xED2FDFDFFB1FA3CC, 0xA4C58C7A86A5F7C0, 0x7A32538128958677, 0x3B8F48986B4BB9AF, 0xC4BFE81B66282193, 0x61D809CCFB21A991, 0x487CAC605DEC8032, 0xE8DAB6909C1BCB7A},
	{0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3, 0x748F82EE5DEAB255, 0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC, 0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9},
	{0xBEF9A3F7B2C67915, 0xC67178F2E372532B, 0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178, 0x06F067AA72176FBA, 0x0A637DC5A2C898A6},
	{0x113F9804BEF90DAE, 0x1B710B35131C471B, 0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C, 0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A},
	{0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817, 0x76D25F6B6A00E3BD, 0x7D2B4B9E1F9B5DBA, 0x87D380BDA5BF7C76, 0x8F1D1E9D9BA2D2F2, 0x99C30D5392F26013, 0xA31D6C0F1D2B36C1},
	{0xACE682DDE0B8D1F6, 0xB6F84565F58D4DAF, 0xC0E3BCC8E3E6A48E, 0xCB3E42B65DCE3055, 0xD5A79147930AA725, 0xE02D9F2A6B6B6B6B, 0xEAE3FE501AA3C36F, 0xF5B9D5A1D9E5C28F},
	{0x0F1D1E9D1BA2D2F2, 0x19C30D5392F26013, 0x231D6C0F1D2B36C1, 0x2DEB83C9A3F1A4B5, 0x37B0C6E7E2FCF4A3, 0x4123456789ABCDE0, 0x4B1D2C3B4A596877, 0x559AA66BB77CC88D},
	{0x5F0F1E2D3C4B5A69, 0x6987A6B5C4D3E2F1, 0x73F1E0D1C2B3A495, 0x7D6C5B4A39281716, 0x87F6E5D4C3B2A190, 0x91E0D1C2B3A49586, 0x9B6C5B4A39281716, 0xA5F6E5D4C3B2A190},
	{0xAF1234567890ABCD, 0xB9CDEF0123456789, 0xC3E4567890ABCDE1, 0xCD0F1234567890AB, 0xD7A9BCDEF0123456, 0xE134567890ABCDEF, 0xEBDF01234567890A, 0xF5A4567890ABCDE1},
	{0xFF00FF00FF00FF00, 0x00FF00FF00FF00FF, 0x13579BDF2468ACE0, 0x02468ACE13579BDF, 0xAAAAAAAA55555555, 0xCCCCCCCC33333333, 0xF0F0F0F00F0F0F0F, 0x0F0F0F0FF0F0F0F0},
	{0x243F6A8885A308D3, 0x13198A2E03707344, 0xA4093822299F31D0, 0x082EFA98EC4E6C89, 0x452821E638D01377, 0xBE5466CF34E90C6C, 0xC0AC29B7C97C50DD, 0x3F84D5B5B5470917},
	{0x9216D5D98979FB1B, 0xD1310BA698DFB5AC, 0x2FFD72DBD01ADFB7, 0xB8E1AFED6A267E96, 0xBA7C9045F12C7F99, 0x24A19947B3916CF7, 0x0801F2E2858EFC16, 0x636920D871574E69},
}

// left rotation for 64-bit
func rotl(x uint64, r uint) uint64 { return (x << r) | (x >> (64 - r)) }

// mix step uses different rotation constants for even/odd steps
var (
	alphaE = [8]uint{23, 59, 7, 3, 13, 43, 17, 29}
	betaE  = [8]uint{59, 7, 3, 13, 43, 17, 29, 23}
	alphaO = [8]uint{5, 11, 27, 32, 37, 43, 49, 55}
	betaO  = [8]uint{11, 27, 32, 37, 43, 49, 55, 5}
)

// compress processes one 2048-bit block
func compress(cv *[16]uint64, m [32]uint64) {
	// split chaining value
	l := [8]uint64{}
	r := [8]uint64{}
	for i := 0; i < 8; i++ {
		l[i] = cv[i]
		r[i] = cv[8+i]
	}

	for step := 0; step < 28; step++ {
		// message injection: 16 words per step, 8 into left, 8 into right
		for i := 0; i < 8; i++ {
			l[i] ^= m[(step*16+i)%32]
			r[i] ^= m[(step*16+8+i)%32]
		}
		// add step constants
		for i := 0; i < 8; i++ {
			l[i] = l[i] + stepConst[step][i]
		}
		// mix
		if step%2 == 0 {
			for i := 0; i < 8; i++ {
				l[i] = rotl(l[i]^r[i], alphaE[i]) + r[i]
				r[i] = rotl(r[i]^l[i], betaE[i]) + l[i]
			}
		} else {
			for i := 0; i < 8; i++ {
				l[i] = rotl(l[i]^r[i], alphaO[i]) + r[i]
				r[i] = rotl(r[i]^l[i], betaO[i]) + l[i]
			}
		}
		// word permutation between steps
		permute(&l, &r)
	}

	// feedforward
	for i := 0; i < 8; i++ {
		cv[i] ^= l[i]
		cv[8+i] ^= r[i]
	}
}

func permute(l, r *[8]uint64) {
	// simple permutation for diffusion (not the official one; compact alternative)
	*l = [8]uint64{l[2], l[3], l[4], l[5], l[6], l[7], l[0], l[1]}
	*r = [8]uint64{r[6], r[7], r[0], r[1], r[2], r[3], r[4], r[5]}
}

// Sum512 computes LSH-512-512 digest of msg and returns a 64-byte slice.
func Sum512(msg []byte) []byte {
	var cv [16]uint64 = iv

	// process full 256-byte blocks
	i := 0
	for ; i+blockBytes <= len(msg); i += blockBytes {
		var m [32]uint64
		for j := 0; j < 32; j++ {
			m[j] = binary.LittleEndian.Uint64(msg[i+j*8:])
		}
		compress(&cv, m)
	}

	// final block with padding (bit padding: append 0x80 then zeros)
	var last [blockBytes]byte
	copy(last[:], msg[i:])
	padIdx := len(msg) - i
	if padIdx < blockBytes {
		last[padIdx] = 0x80
		for k := padIdx + 1; k < blockBytes; k++ {
			last[k] = 0
		}
	}
	var m [32]uint64
	for j := 0; j < 32; j++ {
		m[j] = binary.LittleEndian.Uint64(last[j*8:])
	}
	compress(&cv, m)

	// output: XOR left and right halves then serialize little-endian
	out := make([]byte, 64)
	for i := 0; i < 8; i++ {
		v := cv[i] ^ cv[8+i]
		binary.LittleEndian.PutUint64(out[i*8:], v)
	}
	return out
}
